(defmacro get-n-digits (number-str start n)
  `(loop for i from ,start to (+ ,start ,n -1) collect (parse-integer ,number-str
							       :start i
							       :end (1+ i))))

(defmacro consecutive-product (number &key (start 0) (span (length number)))
  `(apply #'* (get-n-digits ,number ,start ,span)))

(defmacro replace-if (condition old new)
  `(if (funcall ,condition ,new ,old) (setf ,old ,new)))

(defun greatest-product (n)
  (let ((max-prod 0)
	(big-number "73167176531330624919225119674426574742355349194934969835203127745063262395783180169848018694788518438586156078911294949545950173795833195285320880551112540698747158523863050715693290963295227443043557668966489504452445231617318564030987111217223831136222989342338030813533627661428280644448664523874930358907296290491560440772390713810515859307960866701724271218839987979087922749219016997208880937766572733300105336788122023542180975125454059475224352584907711670556013604839586446706324415722155397536978179778461740649551492908625693219784686224828397224137565705605749026140797296865241453510047482166370484403199890008895243450658541227588666881164271714799244429282308634656748139191231628245861786645835912456652947654568284891288314260769004224219022671055626321111109370544217506941658960408071984038509624554443629812309878799272442849091880588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"))
    
    (dotimes (start (- (length big-number) n 1))
      (let ((prod (consecutive-product big-number :start start :span 13)))
	(replace-if #'> max-prod prod)))
    max-prod))

(defun solve ()
  (format t "Solution: ~d" (greatest-product 13)))

(solve)

