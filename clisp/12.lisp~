(defun primep (num)
  (loop for fac from 2 to (floor (isqrt num)) never (zerop (mod num fac))))

(defun make-next-prime ()
  (let ((prime 0))
    #'(lambda ()
	(incf prime 1)
	(loop while (not (primep prime)) do (incf prime))
	prime)))

(defun reduce-factor (num factor)
  (format t "reduce-factor (~d ~d)~%" num factor)
  (let ((factor-list nil))
    (loop while (or
		 (zerop (mod num factor))
		 (= 1 factor)) do
	 (push factor factor-list)
	 (setf num (/ num factor)))
    (values num factor-list)))

(defun new-n-divisors (num)
  (let ((factors nil)
	(next-prime (make-next-prime))
	(i 0)) ;; function which returns the next prime
    (funcall next-prime)
    (loop while (and (/= 1 num) (< i 10)) do
	 (incf i 1)
	 (multiple-value-bind (num-tmp factor-tmp)
	     (reduce-factor num (funcall next-prime))
	   (concatenate 'list factors factor-tmp)
	   (setf num num-tmp)))
    factors))
	 
(defun n-divisors (num)
  (let ((n 0))
   (loop for div from 1 to num when (zerop (mod num div)) do (incf n 1))
   n))

(defun make-next-triangle-function ()
  (let ((last-triangle 0)
	(i 0))
    #'(lambda ()
	(incf i 1)
	(incf last-triangle i)
	last-triangle)))

(defun find-triangle-over-n-divisors (n-divs)
  (let ((triangle 0)
	(next-triangle (make-next-triangle-function)))
	
	(loop until (> (n-divisors triangle) n-divs) do
	     (setf triangle (funcall next-triangle)))
    triangle))

(defun solve ()
  (format t "Solution: ~d~%" (find-triangle-over-n-divisors 500)))

(defun test ()
  (let ((n 70))
    (format t "Over ~d: ~d~%" n (find-triangle-over-n-divisors n))))
